Helidon flies faster with GraalVM
GraalVM is an open source, high-performance, polyglot virtual machine developed by Oracle Labs. GraalVM offers multiple features, including the ability to compile Java code ahead-of-time into a native executable binary. The binary can run natively on the operating system, without a Java runtime!

A native executable offers important benefits, like shorter startup time and lower memory footprint. In addition, when a native executable runs within a container, the size of the container image is reduced (when compared with the same Java application running in a traditional JVM), because the container image doesn’t include a Java runtime. An optimized container size is critical for deploying apps to the cloud.

We are pleased to announce that, starting with version 1.0.3, Helidon supports the GraalVM native-image capability. Now you can easily compile your Helidon application into a native executable with all the advantages described earlier. For example, the sample application described in this article has a startup time measured in tens of milliseconds and a MacOS executable size of only 21MB. Both of those numbers are higher when a traditional JVM is used.

On the other hand, everything is always a tradeoff. Long running applications on traditional JVMs are still demonstrating better performance than GraalVM native executables due to runtime optimization. The key word here is long-running; for short-running applications like serverless functions native executables have a performance advantage. So, you need to decide yourself between fast startup time and small size (and the additional step of building the native executable) versus better performance for long-running applications

Compiling to native binaries introduces certain restrictions for your application. Because of native compilation, you must identify all the points in your code where reflection is used, which is not possible if CDI runtime injection is used. Helidon MP supports MicroProfile standards, which require CDI 2.0. Also, Helidon CDI cloud extensions are implemented as CDI plugins. We didn’t want to limit or complicate the user experience with Helidon MP; so GraalVM is supported in only Helidon SE. It is a perfect fit, because Helidon SE is designed to build small, reactive microservices. It doesn’t use dependency injection, annotations and other such magic . All the Helidon SE features and components (WebServer, Config, Security, Metrics, and Health Checks) are compatible with GraalVM native images.